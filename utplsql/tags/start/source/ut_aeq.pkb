/* Formatted on 2001/09/15 08:57 (RevealNet Formatter v4.4.1) */
CREATE OR REPLACE PACKAGE BODY utaeq
--//-----------------------------------------------------------------------
--//  ** PL/Generator Table Encapsulator for "UTA_EQ"
--//-----------------------------------------------------------------------
--//  (c) COPYRIGHT Personnel Policies, Inc. 2001.
--//               All rights reserved.
--//
--//  No part of this copyrighted work may be reproduced, modified,
--//  or distributed in any form or by any means without the prior
--//  written permission of Personnel Policies, Inc..
--//-----------------------------------------------------------------------
--//  This software was generated by RevealNet's PL/Generator (TM).
--//
--//  For more information, visit www.revealnet.com or call 1.800.REVEAL4
--//-----------------------------------------------------------------------
--//  Stored In:  utaeq.pkb
--//  Created On: September 15, 2001 08:44:51
--//  Created By: SCOTT
--//  PL/Generator Version: PRO-2000.2.9
--//-----------------------------------------------------------------------
IS
   --// Package name and program name globals --//
   c_pkgname    VARCHAR2 (30) := 'utaeq';
   g_progname   VARCHAR2 (30) := NULL;

   --// Update Flag private data structures. --//
   TYPE frcflg_rt IS RECORD (
      outcome_id                    CHAR (1),
      data_type                     CHAR (1),
      check_value_id                CHAR (1),
      against_value_id              CHAR (1));

   frcflg       frcflg_rt;
   emptyfrc     frcflg_rt;
   c_set        CHAR (1)      := 'Y';
   c_noset      CHAR (1)      := 'N';

   FUNCTION version
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '7.09';
   END;

   
--// Private Modules //--

   --// For Dynamic SQL operations; currently unused. //--
   PROCEDURE initcur (cur_inout IN OUT INTEGER)
   IS
   BEGIN
      IF NOT DBMS_SQL.is_open (cur_inout)
      THEN
         cur_inout := DBMS_SQL.open_cursor;
      END IF;
   EXCEPTION
      WHEN INVALID_CURSOR
      THEN
         cur_inout := DBMS_SQL.open_cursor;
   END;

   PROCEDURE start_program (nm IN VARCHAR2, msg IN VARCHAR2 := NULL)
   IS
   BEGIN
      g_progname := nm;
   END;

   PROCEDURE end_program
   IS
   BEGIN
      g_progname := NULL;
   END;

   
--// Cursor management procedures //--

   --// Open the cursors with some options. //--
   PROCEDURE open_allforpky_cur (
      id_in           IN   uta_eq.id%TYPE,
      close_if_open   IN   BOOLEAN := TRUE
   )
   IS
      v_close   BOOLEAN := NVL (close_if_open, TRUE);
      v_open    BOOLEAN := TRUE;
   BEGIN
      start_program ('open_allforpky_cur');

      IF      allforpky_cur%ISOPEN
          AND v_close
      THEN
         CLOSE allforpky_cur;
      ELSIF      allforpky_cur%ISOPEN
             AND NOT v_close
      THEN
         v_open := FALSE;
      END IF;

      IF v_open
      THEN
         OPEN allforpky_cur (id_in);
      END IF;

      end_program;
   END;

   PROCEDURE open_allbypky_cur (close_if_open IN BOOLEAN := TRUE)
   IS
      v_close   BOOLEAN := NVL (close_if_open, TRUE);
      v_open    BOOLEAN := TRUE;
   BEGIN
      IF      allbypky_cur%ISOPEN
          AND v_close
      THEN
         CLOSE allbypky_cur;
      ELSIF      allbypky_cur%ISOPEN
             AND NOT v_close
      THEN
         v_open := FALSE;
      END IF;

      IF v_open
      THEN
         OPEN allbypky_cur;
      END IF;
   END;

   PROCEDURE open_uta_eq_outcome_fk_all_cur (
      outcome_id_in   IN   uta_eq.outcome_id%TYPE,
      close_if_open   IN   BOOLEAN := TRUE
   )
   IS
      v_close   BOOLEAN := NVL (close_if_open, TRUE);
      v_open    BOOLEAN := TRUE;
   BEGIN
      IF      uta_eq_outcome_fk_all_cur%ISOPEN
          AND v_close
      THEN
         CLOSE uta_eq_outcome_fk_all_cur;
      ELSIF      uta_eq_outcome_fk_all_cur%ISOPEN
             AND NOT v_close
      THEN
         v_open := FALSE;
      END IF;

      IF v_open
      THEN
         OPEN uta_eq_outcome_fk_all_cur (outcome_id_in);
      END IF;
   END;

   --// Close the cursors if they are open. //--
   PROCEDURE close_allforpky_cur
   IS
   BEGIN
      IF allforpky_cur%ISOPEN
      THEN
         CLOSE allforpky_cur;
      END IF;
   END;

   PROCEDURE close_allbypky_cur
   IS
   BEGIN
      IF allbypky_cur%ISOPEN
      THEN
         CLOSE allbypky_cur;
      END IF;
   END;

   PROCEDURE close_uta_eq_outcome_fk_all_cu
   IS
   BEGIN
      IF uta_eq_outcome_fk_all_cur%ISOPEN
      THEN
         CLOSE uta_eq_outcome_fk_all_cur;
      END IF;
   END;

   PROCEDURE closeall
   IS
   BEGIN
      close_allforpky_cur;
      close_allbypky_cur;
      close_uta_eq_outcome_fk_all_cu;
   END;

   
--// Emulate aggregate-level record operations. //--

   FUNCTION recseq (rec1 IN allcols_rt, rec2 IN allcols_rt)
      RETURN BOOLEAN
   IS
      unequal_records   EXCEPTION;
      retval            BOOLEAN;
   BEGIN
      retval :=    rec1.id = rec2.id
                OR (    rec1.id IS NULL
                    AND rec2.id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.outcome_id = rec2.outcome_id
                OR (    rec1.outcome_id IS NULL
                    AND rec2.outcome_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.data_type = rec2.data_type
                OR (    rec1.data_type IS NULL
                    AND rec2.data_type IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.check_value_id = rec2.check_value_id
                OR (    rec1.check_value_id IS NULL
                    AND rec2.check_value_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.against_value_id = rec2.against_value_id
                OR (    rec1.against_value_id IS NULL
                    AND rec2.against_value_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      RETURN TRUE;
   EXCEPTION
      WHEN unequal_records
      THEN
         RETURN FALSE;
   END;

   FUNCTION recseq (rec1 IN pky_rt, rec2 IN pky_rt)
      RETURN BOOLEAN
   IS
      unequal_records   EXCEPTION;
      retval            BOOLEAN;
   BEGIN
      retval :=    rec1.id = rec2.id
                OR (    rec1.id IS NULL
                    AND rec2.id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      RETURN TRUE;
   EXCEPTION
      WHEN unequal_records
      THEN
         RETURN FALSE;
   END;

   
--// Is the primary key NOT NULL? //--

   FUNCTION isnullpky (rec_in IN allcols_rt)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN rec_in.id IS NULL;
   END;

   FUNCTION isnullpky (rec_in IN pky_rt)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN rec_in.id IS NULL;
   END;

   
--// Query Processing --//

   FUNCTION onerow_internal (id_in IN uta_eq.id%TYPE)
      RETURN allcols_rt
   IS
      CURSOR onerow_cur
      IS
         SELECT id, outcome_id, data_type, check_value_id,
                against_value_id
           FROM uta_eq
          WHERE id = id_in;

      onerow_rec   allcols_rt;
   BEGIN
      OPEN onerow_cur;
      FETCH onerow_cur INTO onerow_rec;
      CLOSE onerow_cur;
      RETURN onerow_rec;
   END onerow_internal;

   FUNCTION onerow (id_in IN uta_eq.id%TYPE)
      RETURN allcols_rt
   IS
      retval   allcols_rt;
   BEGIN
      retval := onerow_internal (id_in);
      RETURN retval;
   END onerow;

   --// Count of all rows in table and for each foreign key. //--
   FUNCTION rowcount
      RETURN INTEGER
   IS
      retval   INTEGER;
   BEGIN
      SELECT COUNT (*)
        INTO retval
        FROM uta_eq;
      RETURN retval;
   END;

   FUNCTION pkyrowcount (id_in IN uta_eq.id%TYPE)
      RETURN INTEGER
   IS
      retval   INTEGER;
   BEGIN
      SELECT COUNT (*)
        INTO retval
        FROM uta_eq
       WHERE id = id_in;
      RETURN retval;
   END;

   FUNCTION uta_eq_outcome_fkrowcount (
      outcome_id_in   IN   uta_eq.outcome_id%TYPE
   )
      RETURN INTEGER
   IS
      retval   INTEGER;
   BEGIN
      SELECT COUNT (*)
        INTO retval
        FROM uta_eq
       WHERE outcome_id = uta_eq_outcome_fkrowcount.outcome_id_in;
      RETURN retval;
   END;

   --// Generate the next primary key: single column PKYs only --//
   FUNCTION nextpky
      RETURN uta_eq.id%TYPE
   IS
      retval   uta_eq.id%TYPE;
   BEGIN
      SELECT uta_eq_seq.NEXTVAL
        INTO retval
        FROM DUAL;
      RETURN retval;
   END;

   
--// Update Processing --//

   PROCEDURE reset$frc
   IS
   BEGIN
      frcflg := emptyfrc;
   END reset$frc;

   FUNCTION outcome_id$frc (
      outcome_id_in   IN   uta_eq.outcome_id%TYPE DEFAULT NULL
   )
      RETURN uta_eq.outcome_id%TYPE
   IS
   BEGIN
      frcflg.outcome_id := c_set;
      RETURN outcome_id_in;
   END outcome_id$frc;

   FUNCTION data_type$frc (
      data_type_in   IN   uta_eq.data_type%TYPE DEFAULT NULL
   )
      RETURN uta_eq.data_type%TYPE
   IS
   BEGIN
      frcflg.data_type := c_set;
      RETURN data_type_in;
   END data_type$frc;

   FUNCTION check_value_id$frc (
      check_value_id_in   IN   uta_eq.check_value_id%TYPE DEFAULT NULL
   )
      RETURN uta_eq.check_value_id%TYPE
   IS
   BEGIN
      frcflg.check_value_id := c_set;
      RETURN check_value_id_in;
   END check_value_id$frc;

   FUNCTION against_value_id$frc (
      against_value_id_in   IN   uta_eq.against_value_id%TYPE
            DEFAULT NULL
   )
      RETURN uta_eq.against_value_id%TYPE
   IS
   BEGIN
      frcflg.against_value_id := c_set;
      RETURN against_value_id_in;
   END against_value_id$frc;

   PROCEDURE upd (
      id_in                 IN       uta_eq.id%TYPE,
      outcome_id_in         IN       uta_eq.outcome_id%TYPE
            DEFAULT NULL,
      data_type_in          IN       uta_eq.data_type%TYPE DEFAULT NULL,
      check_value_id_in     IN       uta_eq.check_value_id%TYPE
            DEFAULT NULL,
      against_value_id_in   IN       uta_eq.against_value_id%TYPE
            DEFAULT NULL,
      rowcount_out          OUT      INTEGER,
      reset_in              IN       BOOLEAN DEFAULT TRUE
   )
   IS
   BEGIN
      UPDATE uta_eq
         SET outcome_id = DECODE (
                             frcflg.outcome_id,
                             c_set, outcome_id_in,
                             NVL (outcome_id_in, outcome_id)
                          ),
             data_type = DECODE (
                            frcflg.data_type,
                            c_set, data_type_in,
                            NVL (data_type_in, data_type)
                         ),
             check_value_id = DECODE (
                                 frcflg.check_value_id,
                                 c_set, check_value_id_in,
                                 NVL (
                                    check_value_id_in,
                                    check_value_id
                                 )
                              ),
             against_value_id = DECODE (
                                   frcflg.against_value_id,
                                   c_set, against_value_id_in,
                                   NVL (
                                      against_value_id_in,
                                      against_value_id
                                   )
                                )
       WHERE id = id_in;

      rowcount_out := SQL%ROWCOUNT;

      IF reset_in
      THEN
         reset$frc;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END upd;

   --// Record-based Update --//
   PROCEDURE upd (
      rec_in         IN       allcols_rt,
      rowcount_out   OUT      INTEGER,
      reset_in       IN       BOOLEAN DEFAULT TRUE
   )
   IS
   BEGIN
      upd (
         rec_in.id,
         rec_in.outcome_id,
         rec_in.data_type,
         rec_in.check_value_id,
         rec_in.against_value_id,
         rowcount_out,
         reset_in
      );
   END upd;

   
--// Insert Processing --//

   --// Initialize record with default values. --//
   FUNCTION initrec (allnull IN BOOLEAN := FALSE)
      RETURN allcols_rt
   IS
      retval   allcols_rt;
   BEGIN
      IF allnull
      THEN
         NULL;                  /* Default values are NULL already. */
      ELSE
         retval.id := NULL;
         retval.outcome_id := NULL;
         retval.data_type := NULL;
         retval.check_value_id := NULL;
         retval.against_value_id := NULL;
      END IF;

      RETURN retval;
   END;

   --// Initialize record with default values. --//
   PROCEDURE initrec (
      rec_inout   IN OUT   allcols_rt,
      allnull     IN       BOOLEAN := FALSE
   )
   IS
   BEGIN
      rec_inout := initrec;
   END;

   PROCEDURE ins$ins (
      id_in                 IN   uta_eq.id%TYPE,
      outcome_id_in         IN   uta_eq.outcome_id%TYPE DEFAULT NULL,
      data_type_in          IN   uta_eq.data_type%TYPE DEFAULT NULL,
      check_value_id_in     IN   uta_eq.check_value_id%TYPE
            DEFAULT NULL,
      against_value_id_in   IN   uta_eq.against_value_id%TYPE
            DEFAULT NULL,
      upd_on_dup            IN   BOOLEAN := FALSE
   )
   IS
   BEGIN
      INSERT INTO uta_eq
                  (id, outcome_id, data_type,
                   check_value_id, against_value_id)
           VALUES (id_in, outcome_id_in, data_type_in,
                   check_value_id_in, against_value_id_in);
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
         IF NOT NVL (upd_on_dup, FALSE)
         THEN
            RAISE;
         ELSE
            DECLARE
               v_errm       VARCHAR2 (2000)                        := SQLERRM;
               v_rowcount   INTEGER;
               dotloc       INTEGER;
               leftloc      INTEGER;
               c_owner      all_constraints.owner%TYPE;
               c_name       all_constraints.constraint_name%TYPE;
            BEGIN
               dotloc := INSTR (v_errm, '.');
               leftloc := INSTR (v_errm, '(');
               c_owner := SUBSTR (
                             v_errm,
                               leftloc
                             + 1,
                               dotloc
                             - leftloc
                             - 1
                          );
               c_name := SUBSTR (
                            v_errm,
                              dotloc
                            + 1,
                              INSTR (v_errm, ')')
                            - dotloc
                            - 1
                         );

               --// Duplicate based on primary key //--
               IF      'SYS_C004438' = c_name
                   AND /* 2000.2 'SCOTT' */ USER = c_owner
               THEN
                  upd (
                     id_in,
                     outcome_id_in,
                     data_type_in,
                     check_value_id_in,
                     against_value_id_in,
                     v_rowcount,
                     FALSE
                  );
               ELSE
                  --// Unique index violation. Cannot recover... //--
                  RAISE;
               END IF;
            END;
         END IF;
      WHEN OTHERS
      THEN
         RAISE;
   END ins$ins;

   --// Insert 1: with individual fields and return primary key //--
   PROCEDURE ins (
      outcome_id_in         IN       uta_eq.outcome_id%TYPE
            DEFAULT NULL,
      data_type_in          IN       uta_eq.data_type%TYPE DEFAULT NULL,
      check_value_id_in     IN       uta_eq.check_value_id%TYPE
            DEFAULT NULL,
      against_value_id_in   IN       uta_eq.against_value_id%TYPE
            DEFAULT NULL,
      id_out                IN OUT   uta_eq.id%TYPE,
      upd_on_dup            IN       BOOLEAN := FALSE
   )
   IS
      v_pky   INTEGER := nextpky;
   BEGIN
      ins$ins (
         v_pky,
         outcome_id_in,
         data_type_in,
         check_value_id_in,
         against_value_id_in,
         upd_on_dup
      );
      id_out := v_pky;
   END;

   PROCEDURE ins (
      outcome_id_in            IN       uta_eq.outcome_id%TYPE
            DEFAULT NULL,
      data_type_in             IN       uta_eq.data_type%TYPE
            DEFAULT NULL,
      check_value_in           IN       VARCHAR2,
      check_is_expression_in   IN       BOOLEAN,
      against_value_in         IN       VARCHAR2,
      id_out                   IN OUT   uta_eq.id%TYPE,
      upd_on_dup               IN       BOOLEAN := FALSE
   )
   IS
      l_id uta_eq.id%TYPE;
      l_check utv_value.id%TYPE;
      l_against utv_value.id%TYPE;
   BEGIN   
      utvvalue.ins (
         data_type_in => data_type_in,
         is_expression_in => check_is_expression_in,
         value_in => check_value_in,
         id_out => l_check);

      utvvalue.ins (
         data_type_in => data_type_in,
         is_expression_in => TRUE,
         value_in => against_value_in,
         id_out => l_against);
       
      ins (outcome_id_in, data_type_in, l_check, l_against, id_out, upd_on_dup);
   END;

   --// Insert 2: with record, returning primary key. //--
   PROCEDURE ins (
      rec_in       IN       allcols_rt,
      id_out       IN OUT   uta_eq.id%TYPE,
      upd_on_dup   IN       BOOLEAN := FALSE
   )
   IS
      v_pky   INTEGER := nextpky;
   BEGIN
      ins$ins (
         v_pky,
         rec_in.outcome_id,
         rec_in.data_type,
         rec_in.check_value_id,
         rec_in.against_value_id,
         upd_on_dup
      );
      id_out := v_pky;
   END;

   
--// Delete Processing --//

   PROCEDURE del (id_in IN uta_eq.id%TYPE, rowcount_out OUT INTEGER)
   IS
   BEGIN
      DELETE FROM uta_eq
            WHERE id = id_in;

      rowcount_out := SQL%ROWCOUNT;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END del;

   --// Record-based delete --//
   PROCEDURE del (rec_in IN pky_rt, rowcount_out OUT INTEGER)
   IS
   BEGIN
      del (rec_in.id, rowcount_out);
   END del;

   PROCEDURE del (rec_in IN allcols_rt, rowcount_out OUT INTEGER)
   IS
   BEGIN
      del (rec_in.id, rowcount_out);
   END del;

   --// Delete all records for foreign key UTA_EQ_OUTCOME_FK. //--
   PROCEDURE delby_uta_eq_outcome_fk (
      outcome_id_in   IN       uta_eq.outcome_id%TYPE,
      rowcount_out    OUT      INTEGER
   )
   IS
   BEGIN
      DELETE FROM uta_eq
            WHERE outcome_id = delby_uta_eq_outcome_fk.outcome_id_in;

      rowcount_out := SQL%ROWCOUNT;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END delby_uta_eq_outcome_fk;

   --// Program called by database initialization script to pin the package. //--
   PROCEDURE pinme
   IS
   BEGIN
      --// Doesn't do anything except cause the package to be loaded. //--
      NULL;
   END;

--// Initialization section for the package. --//
BEGIN
   NULL; -- Placeholder.
END utaeq;
/

