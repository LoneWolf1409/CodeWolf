CREATE OR REPLACE PACKAGE utaeq
--//-----------------------------------------------------------------------
--//  ** PL/Generator Table Encapsulator for "UTA_EQ"
--//-----------------------------------------------------------------------
--//  (c) COPYRIGHT Personnel Policies, Inc. 2001.
--//               All rights reserved.
--//
--//  No part of this copyrighted work may be reproduced, modified,
--//  or distributed in any form or by any means without the prior
--//  written permission of Personnel Policies, Inc..
--//-----------------------------------------------------------------------
--//  This software was generated by RevealNet's PL/Generator (TM).
--//
--//  For more information, visit www.revealnet.com or call 1.800.REVEAL4
--//-----------------------------------------------------------------------
--//  Stored In:  utaeq.pks
--//  Created On: September 15, 2001 08:44:48
--//  Created By: SCOTT
--//  PL/Generator Version: PRO-2000.2.9
--//-----------------------------------------------------------------------
IS
--// Data Structures //--
   TYPE pky_rt IS RECORD (
      id UTA_EQ.ID%TYPE
      );

   --// Modified version of %ROWTYPE for table with subset of columns //--
   TYPE allcols_rt IS RECORD (
      id UTA_EQ.ID%TYPE,
      outcome_id UTA_EQ.OUTCOME_ID%TYPE,
      data_type UTA_EQ.DATA_TYPE%TYPE,
      check_value_id UTA_EQ.CHECK_VALUE_ID%TYPE,
      against_value_id UTA_EQ.AGAINST_VALUE_ID%TYPE
      );

   TYPE cv_t IS REF CURSOR;

--// Cursors //--

   CURSOR allbypky_cur
   IS
      SELECT
         ID,
         OUTCOME_ID,
         DATA_TYPE,
         CHECK_VALUE_ID,
         AGAINST_VALUE_ID
        FROM UTA_EQ
       ORDER BY
         ID
      ;

   CURSOR allforpky_cur (
      id_in IN UTA_EQ.ID%TYPE
      )
   IS
      SELECT
         ID,
         OUTCOME_ID,
         DATA_TYPE,
         CHECK_VALUE_ID,
         AGAINST_VALUE_ID
        FROM UTA_EQ
       WHERE
         ID = allforpky_cur.id_in
      ;

   --// Specified columns, all rows for this foreign key. //--
   CURSOR uta_eq_outcome_fk_all_cur (
      outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE
      )
   IS
      SELECT
         ID,
         OUTCOME_ID,
         DATA_TYPE,
         CHECK_VALUE_ID,
         AGAINST_VALUE_ID
        FROM UTA_EQ
       WHERE
          OUTCOME_ID = uta_eq_outcome_fk_all_cur.outcome_id_in
      ;

--// Cursor management procedures //--

   --// Open the cursors with some options. //--
   PROCEDURE open_allforpky_cur (
      id_in IN UTA_EQ.ID%TYPE,
      close_if_open IN BOOLEAN := TRUE
      );

   PROCEDURE open_allbypky_cur (
      close_if_open IN BOOLEAN := TRUE
      );

   PROCEDURE open_uta_eq_outcome_fk_all_cur (
      outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE,
      close_if_open IN BOOLEAN := TRUE
      );

   --// Close the cursors if they are open. //--
   PROCEDURE close_allforpky_cur;
   PROCEDURE close_allbypky_cur;
   PROCEDURE close_uta_eq_outcome_fk_all_cu;
   PROCEDURE closeall;

--// Analyze presence of primary key: is it NOT NULL? //--

   FUNCTION isnullpky (
      rec_in IN allcols_rt
      )
   RETURN BOOLEAN;

   FUNCTION isnullpky (
      rec_in IN pky_rt
      )
   RETURN BOOLEAN;

--// Emulate aggregate-level record operations. //--

   FUNCTION recseq (rec1 IN allcols_rt, rec2 IN allcols_rt)
   RETURN BOOLEAN;

   FUNCTION recseq (rec1 IN pky_rt, rec2 IN pky_rt)
   RETURN BOOLEAN;

--// Fetch Data //--

   --// Fetch one row of data for a primary key. //--
   FUNCTION onerow (
      id_in IN UTA_EQ.ID%TYPE
      )
   RETURN allcols_rt;


   --// Count of all rows in table and for each foreign key. //--
   FUNCTION rowcount RETURN INTEGER;
   FUNCTION pkyrowcount (
      id_in IN UTA_EQ.ID%TYPE
      )
      RETURN INTEGER;
   FUNCTION uta_eq_outcome_fkrowcount (
      outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE
      )
      RETURN INTEGER;
--// Update Processing //--

   PROCEDURE reset$frc;

   --// Force setting of NULL values //--

   FUNCTION outcome_id$frc
      (outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE DEFAULT NULL)
      RETURN UTA_EQ.OUTCOME_ID%TYPE;

   FUNCTION data_type$frc
      (data_type_in IN UTA_EQ.DATA_TYPE%TYPE DEFAULT NULL)
      RETURN UTA_EQ.DATA_TYPE%TYPE;

   FUNCTION check_value_id$frc
      (check_value_id_in IN UTA_EQ.CHECK_VALUE_ID%TYPE DEFAULT NULL)
      RETURN UTA_EQ.CHECK_VALUE_ID%TYPE;

   FUNCTION against_value_id$frc
      (against_value_id_in IN UTA_EQ.AGAINST_VALUE_ID%TYPE DEFAULT NULL)
      RETURN UTA_EQ.AGAINST_VALUE_ID%TYPE;

   PROCEDURE upd (
      id_in IN UTA_EQ.ID%TYPE,
      outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE DEFAULT NULL,
      data_type_in IN UTA_EQ.DATA_TYPE%TYPE DEFAULT NULL,
      check_value_id_in IN UTA_EQ.CHECK_VALUE_ID%TYPE DEFAULT NULL,
      against_value_id_in IN UTA_EQ.AGAINST_VALUE_ID%TYPE DEFAULT NULL,
      rowcount_out OUT INTEGER,
      reset_in IN BOOLEAN DEFAULT TRUE
      );

   --// Record-based Update //--

   PROCEDURE upd (rec_in IN allcols_rt,
      rowcount_out OUT INTEGER,
      reset_in IN BOOLEAN DEFAULT TRUE);

--// Insert Processing //--

   --// Initialize record with default values. //--
   FUNCTION initrec (allnull IN BOOLEAN := FALSE) RETURN allcols_rt;

   --// Initialize record with default values. //--
   PROCEDURE initrec (
      rec_inout IN OUT allcols_rt,
      allnull IN BOOLEAN := FALSE);


   --// Generate next primary key: for single column PKs only. //--
   FUNCTION nextpky RETURN UTA_EQ.id%TYPE;

   PROCEDURE ins (
      outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE DEFAULT NULL,
      data_type_in IN UTA_EQ.DATA_TYPE%TYPE DEFAULT NULL,
      check_value_id_in IN UTA_EQ.CHECK_VALUE_ID%TYPE DEFAULT NULL,
      against_value_id_in IN UTA_EQ.AGAINST_VALUE_ID%TYPE DEFAULT NULL,
      id_out IN OUT UTA_EQ.ID%TYPE,
      upd_on_dup IN BOOLEAN := FALSE
      );

   -- Insert values entered by user, create value rows and then
   -- insert the uta_eq row.
   -- ?? Provide lots of overloading or put the conversion logic
   --    inside this procedure based on data_type? For now will
   --    opt for the conversion, first implementing simply for
   --    VARCHAR2. Obviously this would not work for special
   --    datatypes like BLOB.
   PROCEDURE ins (
      outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE DEFAULT NULL,
      data_type_in IN UTA_EQ.DATA_TYPE%TYPE DEFAULT NULL,
      check_value_in IN VARCHAR2,
      check_is_expression_in in BOOLEAN,
      against_value_in IN VARCHAR2,
      id_out IN OUT UTA_EQ.ID%TYPE,
      upd_on_dup IN BOOLEAN := FALSE
      );
      
   PROCEDURE ins (rec_in IN allcols_rt,
      id_out IN OUT UTA_EQ.ID%TYPE,
      upd_on_dup IN BOOLEAN := FALSE
      );

--// Delete Processing //--
   PROCEDURE del (
      id_in IN UTA_EQ.ID%TYPE,
      rowcount_out OUT INTEGER);

   --// Record-based delete //--
   PROCEDURE del (rec_in IN pky_rt,
      rowcount_out OUT INTEGER);

   PROCEDURE del (rec_in IN allcols_rt,
      rowcount_out OUT INTEGER);

   --// Delete all records for this UTA_EQ_OUTCOME_FK foreign key. //--
   PROCEDURE delby_uta_eq_outcome_fk (
      outcome_id_in IN UTA_EQ.OUTCOME_ID%TYPE,
      rowcount_out OUT INTEGER
      );

   --// Program called by database initialization script to pin the package. //--
   PROCEDURE pinme;
   FUNCTION version RETURN VARCHAR2;
END utaeq;
/
