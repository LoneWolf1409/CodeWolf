/* Formatted on 2001/09/15 09:27 (RevealNet Formatter v4.4.1) */
CREATE OR REPLACE PACKAGE BODY utvvalue
--//-----------------------------------------------------------------------
--//  ** PL/Generator Table Encapsulator for "UTV_VALUE"
--//-----------------------------------------------------------------------
--//  (c) COPYRIGHT Personnel Policies, Inc. 2001.
--//               All rights reserved.
--//
--//  No part of this copyrighted work may be reproduced, modified,
--//  or distributed in any form or by any means without the prior
--//  written permission of Personnel Policies, Inc..
--//-----------------------------------------------------------------------
--//  This software was generated by RevealNet's PL/Generator (TM).
--//
--//  For more information, visit www.revealnet.com or call 1.800.REVEAL4
--//-----------------------------------------------------------------------
--//  Stored In:  utvvalue.pkb
--//  Created On: September 15, 2001 09:21:04
--//  Created By: SCOTT
--//  PL/Generator Version: PRO-2000.2.9
--//-----------------------------------------------------------------------
IS
   --// Package name and program name globals --//
   c_pkgname    VARCHAR2 (30) := 'utvvalue';
   g_progname   VARCHAR2 (30) := NULL;

   --// Update Flag private data structures. --//
   TYPE frcflg_rt IS RECORD (
      data_type                     CHAR (1),
      data_type_name                CHAR (1),
      is_expression                 CHAR (1),
      VALUE                         CHAR (1),
      record_id                     CHAR (1),
      object_id                     CHAR (1),
      collection_id                 CHAR (1),
      uri_id                        CHAR (1),
      xml_id                        CHAR (1),
      lob_id                        CHAR (1));

   frcflg       frcflg_rt;
   emptyfrc     frcflg_rt;
   c_set        CHAR (1)      := 'Y';
   c_noset      CHAR (1)      := 'N';

   FUNCTION version
      RETURN VARCHAR2
   IS
   BEGIN
      RETURN '7.09';
   END;

   
--// Private Modules //--

   --// For Dynamic SQL operations; currently unused. //--
   PROCEDURE initcur (cur_inout IN OUT INTEGER)
   IS
   BEGIN
      IF NOT DBMS_SQL.is_open (cur_inout)
      THEN
         cur_inout := DBMS_SQL.open_cursor;
      END IF;
   EXCEPTION
      WHEN INVALID_CURSOR
      THEN
         cur_inout := DBMS_SQL.open_cursor;
   END;

   PROCEDURE start_program (nm IN VARCHAR2, msg IN VARCHAR2 := NULL)
   IS
   BEGIN
      g_progname := nm;
   END;

   PROCEDURE end_program
   IS
   BEGIN
      g_progname := NULL;
   END;

   
--// Cursor management procedures //--

   --// Open the cursors with some options. //--
   PROCEDURE open_allforpky_cur (
      id_in           IN   utv_value.id%TYPE,
      close_if_open   IN   BOOLEAN := TRUE
   )
   IS
      v_close   BOOLEAN := NVL (close_if_open, TRUE);
      v_open    BOOLEAN := TRUE;
   BEGIN
      start_program ('open_allforpky_cur');

      IF      allforpky_cur%ISOPEN
          AND v_close
      THEN
         CLOSE allforpky_cur;
      ELSIF      allforpky_cur%ISOPEN
             AND NOT v_close
      THEN
         v_open := FALSE;
      END IF;

      IF v_open
      THEN
         OPEN allforpky_cur (id_in);
      END IF;

      end_program;
   END;

   PROCEDURE open_allbypky_cur (close_if_open IN BOOLEAN := TRUE)
   IS
      v_close   BOOLEAN := NVL (close_if_open, TRUE);
      v_open    BOOLEAN := TRUE;
   BEGIN
      IF      allbypky_cur%ISOPEN
          AND v_close
      THEN
         CLOSE allbypky_cur;
      ELSIF      allbypky_cur%ISOPEN
             AND NOT v_close
      THEN
         v_open := FALSE;
      END IF;

      IF v_open
      THEN
         OPEN allbypky_cur;
      END IF;
   END;

   --// Close the cursors if they are open. //--
   PROCEDURE close_allforpky_cur
   IS
   BEGIN
      IF allforpky_cur%ISOPEN
      THEN
         CLOSE allforpky_cur;
      END IF;
   END;

   PROCEDURE close_allbypky_cur
   IS
   BEGIN
      IF allbypky_cur%ISOPEN
      THEN
         CLOSE allbypky_cur;
      END IF;
   END;

   PROCEDURE closeall
   IS
   BEGIN
      close_allforpky_cur;
      close_allbypky_cur;
   END;

   
--// Emulate aggregate-level record operations. //--

   FUNCTION recseq (rec1 IN allcols_rt, rec2 IN allcols_rt)
      RETURN BOOLEAN
   IS
      unequal_records   EXCEPTION;
      retval            BOOLEAN;
   BEGIN
      retval :=    rec1.id = rec2.id
                OR (    rec1.id IS NULL
                    AND rec2.id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.data_type = rec2.data_type
                OR (    rec1.data_type IS NULL
                    AND rec2.data_type IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.data_type_name = rec2.data_type_name
                OR (    rec1.data_type_name IS NULL
                    AND rec2.data_type_name IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.is_expression = rec2.is_expression
                OR (    rec1.is_expression IS NULL
                    AND rec2.is_expression IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.VALUE = rec2.VALUE
                OR (    rec1.VALUE IS NULL
                    AND rec2.VALUE IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.record_id = rec2.record_id
                OR (    rec1.record_id IS NULL
                    AND rec2.record_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.object_id = rec2.object_id
                OR (    rec1.object_id IS NULL
                    AND rec2.object_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.collection_id = rec2.collection_id
                OR (    rec1.collection_id IS NULL
                    AND rec2.collection_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.uri_id = rec2.uri_id
                OR (    rec1.uri_id IS NULL
                    AND rec2.uri_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.xml_id = rec2.xml_id
                OR (    rec1.xml_id IS NULL
                    AND rec2.xml_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      retval :=    rec1.lob_id = rec2.lob_id
                OR (    rec1.lob_id IS NULL
                    AND rec2.lob_id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      RETURN TRUE;
   EXCEPTION
      WHEN unequal_records
      THEN
         RETURN FALSE;
   END;

   FUNCTION recseq (rec1 IN pky_rt, rec2 IN pky_rt)
      RETURN BOOLEAN
   IS
      unequal_records   EXCEPTION;
      retval            BOOLEAN;
   BEGIN
      retval :=    rec1.id = rec2.id
                OR (    rec1.id IS NULL
                    AND rec2.id IS NULL
                   );

      IF NOT NVL (retval, FALSE)
      THEN
         RAISE unequal_records;
      END IF;

      RETURN TRUE;
   EXCEPTION
      WHEN unequal_records
      THEN
         RETURN FALSE;
   END;

   
--// Is the primary key NOT NULL? //--

   FUNCTION isnullpky (rec_in IN allcols_rt)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN rec_in.id IS NULL;
   END;

   FUNCTION isnullpky (rec_in IN pky_rt)
      RETURN BOOLEAN
   IS
   BEGIN
      RETURN rec_in.id IS NULL;
   END;

   
--// Query Processing --//

   FUNCTION onerow_internal (id_in IN utv_value.id%TYPE)
      RETURN allcols_rt
   IS
      CURSOR onerow_cur
      IS
         SELECT id, data_type, data_type_name, is_expression, VALUE,
                record_id, object_id, collection_id, uri_id, xml_id,
                lob_id
           FROM utv_value
          WHERE id = id_in;

      onerow_rec   allcols_rt;
   BEGIN
      OPEN onerow_cur;
      FETCH onerow_cur INTO onerow_rec;
      CLOSE onerow_cur;
      RETURN onerow_rec;
   END onerow_internal;

   FUNCTION onerow (id_in IN utv_value.id%TYPE)
      RETURN allcols_rt
   IS
      retval   allcols_rt;
   BEGIN
      retval := onerow_internal (id_in);
      RETURN retval;
   END onerow;

   --// Count of all rows in table and for each foreign key. //--
   FUNCTION rowcount
      RETURN INTEGER
   IS
      retval   INTEGER;
   BEGIN
      SELECT COUNT (*)
        INTO retval
        FROM utv_value;
      RETURN retval;
   END;

   FUNCTION pkyrowcount (id_in IN utv_value.id%TYPE)
      RETURN INTEGER
   IS
      retval   INTEGER;
   BEGIN
      SELECT COUNT (*)
        INTO retval
        FROM utv_value
       WHERE id = id_in;
      RETURN retval;
   END;

   --// Generate the next primary key: single column PKYs only --//
   FUNCTION nextpky
      RETURN utv_value.id%TYPE
   IS
      retval   utv_value.id%TYPE;
   BEGIN
      SELECT utv_value_seq.NEXTVAL
        INTO retval
        FROM DUAL;
      RETURN retval;
   END;

   
--// Update Processing --//

   PROCEDURE reset$frc
   IS
   BEGIN
      frcflg := emptyfrc;
   END reset$frc;

   FUNCTION data_type$frc (
      data_type_in   IN   utv_value.data_type%TYPE DEFAULT NULL
   )
      RETURN utv_value.data_type%TYPE
   IS
   BEGIN
      frcflg.data_type := c_set;
      RETURN data_type_in;
   END data_type$frc;

   FUNCTION data_type_name$frc (
      data_type_name_in   IN   utv_value.data_type_name%TYPE
            DEFAULT NULL
   )
      RETURN utv_value.data_type_name%TYPE
   IS
   BEGIN
      frcflg.data_type_name := c_set;
      RETURN data_type_name_in;
   END data_type_name$frc;

   FUNCTION is_expression$frc (
      is_expression_in   IN   utv_value.is_expression%TYPE DEFAULT NULL
   )
      RETURN utv_value.is_expression%TYPE
   IS
   BEGIN
      frcflg.is_expression := c_set;
      RETURN is_expression_in;
   END is_expression$frc;

   FUNCTION value$frc (value_in IN utv_value.VALUE%TYPE DEFAULT NULL)
      RETURN utv_value.VALUE%TYPE
   IS
   BEGIN
      frcflg.VALUE := c_set;
      RETURN value_in;
   END value$frc;

   FUNCTION record_id$frc (
      record_id_in   IN   utv_value.record_id%TYPE DEFAULT NULL
   )
      RETURN utv_value.record_id%TYPE
   IS
   BEGIN
      frcflg.record_id := c_set;
      RETURN record_id_in;
   END record_id$frc;

   FUNCTION object_id$frc (
      object_id_in   IN   utv_value.object_id%TYPE DEFAULT NULL
   )
      RETURN utv_value.object_id%TYPE
   IS
   BEGIN
      frcflg.object_id := c_set;
      RETURN object_id_in;
   END object_id$frc;

   FUNCTION collection_id$frc (
      collection_id_in   IN   utv_value.collection_id%TYPE DEFAULT NULL
   )
      RETURN utv_value.collection_id%TYPE
   IS
   BEGIN
      frcflg.collection_id := c_set;
      RETURN collection_id_in;
   END collection_id$frc;

   FUNCTION uri_id$frc (
      uri_id_in   IN   utv_value.uri_id%TYPE DEFAULT NULL
   )
      RETURN utv_value.uri_id%TYPE
   IS
   BEGIN
      frcflg.uri_id := c_set;
      RETURN uri_id_in;
   END uri_id$frc;

   FUNCTION xml_id$frc (
      xml_id_in   IN   utv_value.xml_id%TYPE DEFAULT NULL
   )
      RETURN utv_value.xml_id%TYPE
   IS
   BEGIN
      frcflg.xml_id := c_set;
      RETURN xml_id_in;
   END xml_id$frc;

   FUNCTION lob_id$frc (
      lob_id_in   IN   utv_value.lob_id%TYPE DEFAULT NULL
   )
      RETURN utv_value.lob_id%TYPE
   IS
   BEGIN
      frcflg.lob_id := c_set;
      RETURN lob_id_in;
   END lob_id$frc;

   PROCEDURE upd (
      id_in               IN       utv_value.id%TYPE,
      data_type_in        IN       utv_value.data_type%TYPE
            DEFAULT NULL,
      data_type_name_in   IN       utv_value.data_type_name%TYPE
            DEFAULT NULL,
      is_expression_in    IN       utv_value.is_expression%TYPE
            DEFAULT NULL,
      value_in            IN       utv_value.VALUE%TYPE DEFAULT NULL,
      record_id_in        IN       utv_value.record_id%TYPE
            DEFAULT NULL,
      object_id_in        IN       utv_value.object_id%TYPE
            DEFAULT NULL,
      collection_id_in    IN       utv_value.collection_id%TYPE
            DEFAULT NULL,
      uri_id_in           IN       utv_value.uri_id%TYPE DEFAULT NULL,
      xml_id_in           IN       utv_value.xml_id%TYPE DEFAULT NULL,
      lob_id_in           IN       utv_value.lob_id%TYPE DEFAULT NULL,
      rowcount_out        OUT      INTEGER,
      reset_in            IN       BOOLEAN DEFAULT TRUE
   )
   IS
   BEGIN
      UPDATE utv_value
         SET data_type = DECODE (
                            frcflg.data_type,
                            c_set, data_type_in,
                            NVL (data_type_in, data_type)
                         ),
             data_type_name = DECODE (
                                 frcflg.data_type_name,
                                 c_set, data_type_name_in,
                                 NVL (
                                    data_type_name_in,
                                    data_type_name
                                 )
                              ),
             is_expression = DECODE (
                                frcflg.is_expression,
                                c_set, is_expression_in,
                                NVL (is_expression_in, is_expression)
                             ),
             VALUE = DECODE (
                        frcflg.VALUE,
                        c_set, value_in,
                        NVL (value_in, VALUE)
                     ),
             record_id = DECODE (
                            frcflg.record_id,
                            c_set, record_id_in,
                            NVL (record_id_in, record_id)
                         ),
             object_id = DECODE (
                            frcflg.object_id,
                            c_set, object_id_in,
                            NVL (object_id_in, object_id)
                         ),
             collection_id = DECODE (
                                frcflg.collection_id,
                                c_set, collection_id_in,
                                NVL (collection_id_in, collection_id)
                             ),
             uri_id = DECODE (
                         frcflg.uri_id,
                         c_set, uri_id_in,
                         NVL (uri_id_in, uri_id)
                      ),
             xml_id = DECODE (
                         frcflg.xml_id,
                         c_set, xml_id_in,
                         NVL (xml_id_in, xml_id)
                      ),
             lob_id = DECODE (
                         frcflg.lob_id,
                         c_set, lob_id_in,
                         NVL (lob_id_in, lob_id)
                      )
       WHERE id = id_in;

      rowcount_out := SQL%ROWCOUNT;

      IF reset_in
      THEN
         reset$frc;
      END IF;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END upd;

   --// Record-based Update --//
   PROCEDURE upd (
      rec_in         IN       allcols_rt,
      rowcount_out   OUT      INTEGER,
      reset_in       IN       BOOLEAN DEFAULT TRUE
   )
   IS
   BEGIN
      upd (
         rec_in.id,
         rec_in.data_type,
         rec_in.data_type_name,
         rec_in.is_expression,
         rec_in.VALUE,
         rec_in.record_id,
         rec_in.object_id,
         rec_in.collection_id,
         rec_in.uri_id,
         rec_in.xml_id,
         rec_in.lob_id,
         rowcount_out,
         reset_in
      );
   END upd;

   
--// Insert Processing --//

   --// Initialize record with default values. --//
   FUNCTION initrec (allnull IN BOOLEAN := FALSE)
      RETURN allcols_rt
   IS
      retval   allcols_rt;
   BEGIN
      IF allnull
      THEN
         NULL;                  /* Default values are NULL already. */
      ELSE
         retval.id := NULL;
         retval.data_type := NULL;
         retval.data_type_name := NULL;
         retval.is_expression := NULL;
         retval.VALUE := NULL;
         retval.record_id := NULL;
         retval.object_id := NULL;
         retval.collection_id := NULL;
         retval.uri_id := NULL;
         retval.xml_id := NULL;
         retval.lob_id := NULL;
      END IF;

      RETURN retval;
   END;

   --// Initialize record with default values. --//
   PROCEDURE initrec (
      rec_inout   IN OUT   allcols_rt,
      allnull     IN       BOOLEAN := FALSE
   )
   IS
   BEGIN
      rec_inout := initrec;
   END;

   PROCEDURE ins$ins (
      id_in               IN   utv_value.id%TYPE,
      data_type_in        IN   utv_value.data_type%TYPE DEFAULT NULL,
      data_type_name_in   IN   utv_value.data_type_name%TYPE
            DEFAULT NULL,
      is_expression_in    IN   utv_value.is_expression%TYPE
            DEFAULT NULL,
      value_in            IN   utv_value.VALUE%TYPE DEFAULT NULL,
      record_id_in        IN   utv_value.record_id%TYPE DEFAULT NULL,
      object_id_in        IN   utv_value.object_id%TYPE DEFAULT NULL,
      collection_id_in    IN   utv_value.collection_id%TYPE
            DEFAULT NULL,
      uri_id_in           IN   utv_value.uri_id%TYPE DEFAULT NULL,
      xml_id_in           IN   utv_value.xml_id%TYPE DEFAULT NULL,
      lob_id_in           IN   utv_value.lob_id%TYPE DEFAULT NULL,
      upd_on_dup          IN   BOOLEAN := FALSE
   )
   IS
   BEGIN
      INSERT INTO utv_value
                  (id, data_type, data_type_name,
                   is_expression, VALUE, record_id,
                   object_id, collection_id, uri_id,
                   xml_id, lob_id)
           VALUES (id_in, data_type_in, data_type_name_in,
                   is_expression_in, value_in, record_id_in,
                   object_id_in, collection_id_in, uri_id_in,
                   xml_id_in, lob_id_in);
   EXCEPTION
      WHEN DUP_VAL_ON_INDEX
      THEN
         IF NOT NVL (upd_on_dup, FALSE)
         THEN
            RAISE;
         ELSE
            DECLARE
               v_errm       VARCHAR2 (2000)                        := SQLERRM;
               v_rowcount   INTEGER;
               dotloc       INTEGER;
               leftloc      INTEGER;
               c_owner      all_constraints.owner%TYPE;
               c_name       all_constraints.constraint_name%TYPE;
            BEGIN
               dotloc := INSTR (v_errm, '.');
               leftloc := INSTR (v_errm, '(');
               c_owner := SUBSTR (
                             v_errm,
                               leftloc
                             + 1,
                               dotloc
                             - leftloc
                             - 1
                          );
               c_name := SUBSTR (
                            v_errm,
                              dotloc
                            + 1,
                              INSTR (v_errm, ')')
                            - dotloc
                            - 1
                         );

               --// Duplicate based on primary key //--
               IF      'SYS_C004468' = c_name
                   AND /* 2000.2 'SCOTT' */ USER = c_owner
               THEN
                  upd (
                     id_in,
                     data_type_in,
                     data_type_name_in,
                     is_expression_in,
                     value_in,
                     record_id_in,
                     object_id_in,
                     collection_id_in,
                     uri_id_in,
                     xml_id_in,
                     lob_id_in,
                     v_rowcount,
                     FALSE
                  );
               ELSE
                  --// Unique index violation. Cannot recover... //--
                  RAISE;
               END IF;
            END;
         END IF;
      WHEN OTHERS
      THEN
         RAISE;
   END ins$ins;

   --// Insert 1: with individual fields and return primary key //--
   PROCEDURE ins (
      data_type_in        IN       utv_value.data_type%TYPE
            DEFAULT NULL,
      data_type_name_in   IN       utv_value.data_type_name%TYPE
            DEFAULT NULL,
      is_expression_in    IN       utv_value.is_expression%TYPE
            DEFAULT NULL,
      value_in            IN       utv_value.VALUE%TYPE DEFAULT NULL,
      record_id_in        IN       utv_value.record_id%TYPE
            DEFAULT NULL,
      object_id_in        IN       utv_value.object_id%TYPE
            DEFAULT NULL,
      collection_id_in    IN       utv_value.collection_id%TYPE
            DEFAULT NULL,
      uri_id_in           IN       utv_value.uri_id%TYPE DEFAULT NULL,
      xml_id_in           IN       utv_value.xml_id%TYPE DEFAULT NULL,
      lob_id_in           IN       utv_value.lob_id%TYPE DEFAULT NULL,
      id_out              IN OUT   utv_value.id%TYPE,
      upd_on_dup          IN       BOOLEAN := FALSE
   )
   IS
      v_pky   INTEGER := nextpky;
   BEGIN
      ins$ins (
         v_pky,
         data_type_in,
         data_type_name_in,
         is_expression_in,
         value_in,
         record_id_in,
         object_id_in,
         collection_id_in,
         uri_id_in,
         xml_id_in,
         lob_id_in,
         upd_on_dup
      );
      id_out := v_pky;
   END;

   -- Simple insert for expressions/scalars only.
   PROCEDURE ins (
      data_type_in       IN       utv_value.data_type%TYPE DEFAULT NULL,
      is_expression_in   IN       BOOLEAN,
      value_in           IN       utv_value.VALUE%TYPE DEFAULT NULL,
      id_out             IN OUT   utv_value.id%TYPE,
      upd_on_dup         IN       BOOLEAN := FALSE
   )
   IS
   BEGIN
      ins (
         data_type_in=> data_type_in,
         is_expression_in=> utplsql.ifelse (
                     is_expression_in,
                     utplsql.c_yes,
                     utplsql.c_no
                  ),
         value_in=> value_in,
         id_out=> id_out,
         upd_on_dup=> upd_on_dup
      );
   END;

   --// Insert 2: with record, returning primary key. //--
   PROCEDURE ins (
      rec_in       IN       allcols_rt,
      id_out       IN OUT   utv_value.id%TYPE,
      upd_on_dup   IN       BOOLEAN := FALSE
   )
   IS
      v_pky   INTEGER := nextpky;
   BEGIN
      ins$ins (
         v_pky,
         rec_in.data_type,
         rec_in.data_type_name,
         rec_in.is_expression,
         rec_in.VALUE,
         rec_in.record_id,
         rec_in.object_id,
         rec_in.collection_id,
         rec_in.uri_id,
         rec_in.xml_id,
         rec_in.lob_id,
         upd_on_dup
      );
      id_out := v_pky;
   END;

   
--// Delete Processing --//

   PROCEDURE del (id_in IN utv_value.id%TYPE, rowcount_out OUT INTEGER)
   IS
   BEGIN
      DELETE FROM utv_value
            WHERE id = id_in;

      rowcount_out := SQL%ROWCOUNT;
   EXCEPTION
      WHEN OTHERS
      THEN
         RAISE;
   END del;

   --// Record-based delete --//
   PROCEDURE del (rec_in IN pky_rt, rowcount_out OUT INTEGER)
   IS
   BEGIN
      del (rec_in.id, rowcount_out);
   END del;

   PROCEDURE del (rec_in IN allcols_rt, rowcount_out OUT INTEGER)
   IS
   BEGIN
      del (rec_in.id, rowcount_out);
   END del;

   --// Program called by database initialization script to pin the package. //--
   PROCEDURE pinme
   IS
   BEGIN
      --// Doesn't do anything except cause the package to be loaded. //--
      NULL;
   END;

--// Initialization section for the package. --//
BEGIN
   NULL; -- Placeholder.
END utvvalue;
/

